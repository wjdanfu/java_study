# 5주차
## CHAPTER 3
### 생각해보기 
#### 1) 상속을 이용하면 어떤 문제점을 해결할 수 있을 것 같나요?
상속을 활용하면 코드의 재사용성을 높이고 중복을 제거하여 생산성 향상과 보다 용이한 유지보수가 가능해집니다.
```
상속의 특징
- 기존의 클래스를 재사용하여 새로운 클래스를 작성한다.
- 두개 이상의 클래스를 부모와 자식으로 관계를 맺어준다.
- 자식 클래스는 부모 클래스의 모든 멤버를 상속받는다. (생성자, 초기화블럭 제외)
- 다중 상속이 불가능하다.
- 자식 클래스의 멤버 개수는 부모 클래스와 같거나 많다.
- 부모 클래스가 변경되면 자식 클래스는 영향을 받지만, 자식 클래스가 변경되는 것은 부모 클래스에 영향을 주지 않는다.
- 상속받은 자식 클래스의 인스턴스 생성시 부모 클래스의 멤버도 함께 생성된다.
```



출처: https://freestrokes.tistory.com/59 [FREESTROKES DEVLOG]
#### 2) 어떤 경우에 부모 클래스의 메소드를 재정의해야 할까요? 구체적인 상황을 생각해 봅시다.
자식이 부모 클래스의 필드, 메소드들을 상속받지만, 그 중에서는 재정의가 필요한 메소드가 있을 수도 있습니다.

자바는 상속된 메소드 중 일부를 자식 클래스에서 다시 수정하여 사용할 수 있게끔 해 줍니다.

이 기능을 메소드 오버라이딩(Overriding) 이라고 합니다.


메소드를 오버라이딩 할 시 몇 가지 중요한 주의사항이 있습니다.
- 재정의할 부모의 메소드와 동일한 메소드명, 리턴 타입, 매개 변수 리스트로 작성해야 한다.

- 메소드의 접근 제한자는 부모의 것보다 더 제한이 강한 것을 사용할 수 없다. (예를 들어 부모의 메소드가 public 이었는데, 자식이 오버라이딩 할 때 private로 할 수 없음)

- 새로운 Exception을 throws 할 수 없다.


@Override 어노테이션은 컴파일러에게 메소드가 정확하게 오버라이딩 되었는지 확인을 요청하는 것으로,
생략되도 상관은 없으나 개발자의 실수를 체크해 주므로 프로그램 안정성에 도움을 줍니다.

그리고 재정의한 곳의 선언부를 보면 부모 메소드와 리턴 타입(int)과 메소드명(CalCul), 매개변수 리스트(int …) 이 모두 동일한 것을 알 수 있습니다.

이렇게 재정의가 되었다면, 기존 부모의 메소드는 가려지게 됩니다.

따라서 main 메소드 등에서 자식 객체를 생성해 해당 메소드를 호출하면, 오버라이딩된 자식 메소드를 호출하게 됩니다.

출처 )https://chanhuiseok.github.io/posts/java-2/

#### 3) super 키워드는 어떤 점에서 편리한가요?
부모클래스 메소드의 기능을 거의 그대로 사용하고싶고, 기능 몇개만 더추가하고 싶을때 자식 클래스에서 코드를 추가후 return값을 super로 설정하면 자식클래스에 orverriding 할때 짧은 코드로 사용할수 있습니다.

#### 4) 왜 인자를 받는 생성자를 만들게 되면 기본 생성자는 암묵적으로 만들어지지 않을까요?
```
부모 클래스에 생성자가 있는 경우에 자식 클래스의 생성자는 무엇을 호출할까요?

자식 클래스에 이미 해당하는 생성자가 만들어져 있다면 그것을 호출하겠지만,

그렇지 않다면 암묵적으로 부모 클래스의 생성자(super())를 호출하게 됩니다.

하지만 상속관계에 있는 클래스의 생성자에 기본 생성자(인자가 전혀 없는 생성자)가 아닌

인자가 포함된 생성자를 사용하는 경우 주의해야 합니다.

위와 같이 부모 클래스에 기본 생성자가 아닌 인자를 주는 생성자만 명시된 경우,

자식 클래스에서 생성자를 명시적으로 만들지 않는다면 컴파일이 되지 않습니다.

왜냐하면, 자식 클래스에서 생성자를 호출하는 경우(인스턴스 생성),

정의한 생성자가 없기 때문에 부모 클래스의 생성자(super())를 사용해야 하는데,

명시적으로 인자를 받는 생성자만 부모 클래스에 만들어져 있기 때문에

기본 생성자가 없는 것으로 받아들여지기 때문입니다.

자식 클래스의 경우에도, 기본 생성자는 명시적으로 만들지 않고,

인자를 받는 생성자만 만들었을 경우에는 인수를 주지 않고 인스턴스를 생성할 수 없습니다.
```

출처 ) https://github.com/heonilp/study/tree/master/JAVA%20study/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9E%90%EB%B0%942/4.%20JAVA%20%EC%83%81%EC%86%8D

